package problems

import (
	"sync"

	"github.com/dbtrnl/project-euler.go/internal/entities"
	"github.com/dbtrnl/project-euler.go/internal/input_data"
	"github.com/dbtrnl/project-euler.go/pkg/utils"
)

// Problem 1 - Multiples of 3 and 5
//
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
// The sum of these multiples is 23.
//
// Find the sum of all the multiples of 3 or 5 below 1000.
func Problem1(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	limit, multiples, answer := 1000, []int{}, 0

	for num := 0; num < limit; num++ {
		if num%3 == 0 || num%5 == 0 {
			multiples = append(multiples, num)
		}
	}
	for _, num := range multiples {
		answer += num
	}
	// pc, _, _, _ := runtime.Caller(1)
	// name := runtime.FuncForPC(pc).Name()
	// fnName := runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()
	// fmt.Println(name, fnName)
	ch <- answer
}

// Problem 2 - Even Fibonacci Numbers
//
// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be:
//
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
func Problem2(wg *sync.WaitGroup, ch chan<- int) {
	var answer int
	defer wg.Done()
	limit := 4000000
	fibArr := utils.ReturnFibonacciNumbersUntil(limit)

	for i := 0; i <= len(fibArr)-1; i++ {
		if fibArr[i]%2 == 0 {
			answer += fibArr[i]
		}
	}
	ch <- answer
}

// Problem 3 - Largest Prime Factor
//
// The prime factors of 13195 are 5, 7, 13 and 29.
//
// What is the largest prime factor of the number 600851475143?
func Problem3(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	input := 600851475143
	answer := utils.FindLargestPrimeFactor(input)
	ch <- answer
}

// Problem 4 - Largest palindrome product
//
// A palindromic number reads the same both ways.
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
//
// Find the largest palindrome made from the product of two 3-digit numbers
func Problem4(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	currentLargestPalindrome := 0

	for i := 100; i < 1000; i++ {
		for j := 100; j < 1000; j++ {
			currentNumber := i * j
			if utils.IsNumberPalindrome(currentNumber) && currentLargestPalindrome < currentNumber {
				currentLargestPalindrome = currentNumber
			}
		}
	}
	ch <- currentLargestPalindrome
}

// Problem 5 - Smallest multiple
//
// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
//
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
func Problem5(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	min_div, max_div := 1, 20

	currNum := 1
	isDivisible := false

	for !isDivisible {
		isDivisible = utils.IsEvenlyDivisibleByEveryNumberInInterval(currNum, min_div, max_div, "desc")
		if isDivisible {
			break
		} else {
			currNum++
		}
	}
	ch <- currNum
}

// Problem 6 - Sum square difference
//
// The sum of the squares of the first ten natural numbers is: 1^2 + 2^2 ... + 10^2 = 385
//
// The square of the sum of the first ten natural numbers is: (1+2+...+10)^2 = 55^2 = 3025
//
// Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025-385=2640.
// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
func Problem6(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	sumOfSquares := utils.FindSumOfNumberIntervalSquares(1, 100)
	squareOfSum := utils.FindSquareOfNumberIntervalSum(1, 100)
	answer := squareOfSum - sumOfSquares

	ch <- answer
}

// Problem 7 - 10001st prime
//
// By listing the first six prime numbers:
// 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
//
// What is the 10.001st prime number?
func Problem7(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	nth := 10001
	answer := utils.FindNthPrime(nth)
	ch <- answer
}

// Problem 8 - Largest product in a series
//
// The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product.
//
// What is the value of this product?
func Problem8(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	series_size, greatestProduct := 13, 0

	for j := 0; j < len(input_data.Problem8Input)-series_size-1; j++ {
		currentSeries := input_data.Problem8Input[j : j+series_size]
		currentSeriesSum := utils.FindProductOfDigitsInNumberSeries(currentSeries)

		if currentSeriesSum != 0 && currentSeriesSum > greatestProduct {
			greatestProduct = currentSeriesSum
		}
	}
	ch <- greatestProduct
}

// Problem 9 - Special pythagorean triplet
//
// A Pythagorean triplet is a set of three natural numbers, "a < b < c", for which: "a^2 + b^2 = c^2"
//
// For example: 3^2+ 4^2 = 9 + 16 = 25 = 5^2.
//
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
//
// Find the product abc.
func Problem9(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	max_iterations := 1000
	var newTripletSet entities.TripletSet
	answer := 0

	for c := 3; c <= max_iterations; c++ {
		for b := 2; b < c; b++ {
			for a := 1; a < b; a++ {
				newTripletSet = entities.TripletSet{A: a, B: b, C: c}
				if newTripletSet.A+newTripletSet.B+newTripletSet.C == 1000 && newTripletSet.IsPythagoreanTriplet() == true {
					answer = newTripletSet.A * newTripletSet.B * newTripletSet.C
				}
			}
		}
	}
	ch <- answer
}

// Problem 10 - Summation of primes
//
// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
//
// Find the sum of all the primes below two million
func Problem10(wg *sync.WaitGroup, ch chan<- int) {
	defer wg.Done()
	max_prime_value := 2000000
	answer := 0
	primesArray := utils.FindAllPrimesSmallerThan(max_prime_value)

	for _, num := range primesArray {
		answer += num
	}
	ch <- answer
}
