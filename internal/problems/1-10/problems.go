package problems

import (
	"github.com/dbtrnl/project-euler/golang/internal/entities.go"
	"github.com/dbtrnl/project-euler/golang/internal/input_data"
	"github.com/dbtrnl/project-euler/golang/pkg/utils"
)

/*
**Problem 1 - Multiples of 3 and 5**

If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.

The sum of these multiples is 23.

---
Find the sum of all the multiples of 3 or 5 below 1000.
*/
func Problem1() int {
	limit, multiples, result := 1000, []int{}, 0

	for num := 0; num < limit; num++ {
		if num%3 == 0 || num%5 == 0 {
			multiples = append(multiples, num)
		}
	}
	for _, num := range multiples {
		result += num
	}
	return result
}

/*
**Problem 2 - Even Fibonacci Numbers**

Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

---
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
*/
func Problem2() int {
	var sum int
	limit := 4000000
	fibArr := utils.ReturnFibonacciNumbersUntil(limit)

	for i := 0; i <= len(fibArr)-1; i++ {
		if fibArr[i]%2 == 0 {
			sum += fibArr[i]
		}
	}
	return sum
}

/*
**Problem 3 - Largest Prime Factor**

The prime factors of 13195 are 5, 7, 13 and 29.

---
What is the largest prime factor of the number 600851475143?
*/
func Problem3() int {
	input := 600851475143
	return utils.FindLargestPrimeFactor(input)
}

func Problem4() int {
	currentLargestPalindrome := 0

	for i := 100; i < 1000; i++ {
		for j := 100; j < 1000; j++ {
			currentNumber := i * j
			if utils.IsNumberPalindrome(currentNumber) && currentLargestPalindrome < currentNumber {
				currentLargestPalindrome = currentNumber
			}
		}
	}
	return currentLargestPalindrome
}

func Problem5() int {
	min_div, max_div := 1, 20

	currNum := 1
	isDivisible := false

	for !isDivisible {
		isDivisible = utils.IsEvenlyDivisibleByEveryNumberInInterval(currNum, min_div, max_div, "desc")
		if isDivisible {
			break
		} else { currNum++ }
	}
	return currNum
}

func Problem6() int {
	sumOfSquares := utils.FindSumOfNumberIntervalSquares(1, 100)
	squareOfSum := utils.FindSquareOfNumberIntervalSum(1, 100)
	answer := squareOfSum - sumOfSquares

	return answer
}

func Problem7() int {
	nth := 10001
	answer := utils.FindNthPrime(nth)
	return answer
}

func Problem8() int {
	series_size, greatestProduct := 13, 0

	for j := 0; j < len(input_data.Problem8Input) - series_size - 1; j++ {
		currentSeries := input_data.Problem8Input[j : j+series_size]
		currentSeriesSum := utils.FindProductOfDigitsInNumberSeries(currentSeries)

		if (currentSeriesSum != 0 && currentSeriesSum > greatestProduct) {
			greatestProduct = currentSeriesSum
		}
	}
	return greatestProduct
}

func Problem9() int {
	max_iterations := 1000
	var newTripletSet entities.TripletSetObject
	answer := 0

	for c := 3; c <= max_iterations; c++ {
		for b := 2; b < c; b++ {
			for a := 1; a < b; a++ {
				newTripletSet = entities.TripletSetObject{A: a, B: b, C: c}
				if newTripletSet.A + newTripletSet.B + newTripletSet.C == 1000 && newTripletSet.IsPythagoreanTriplet() == true {
					answer = newTripletSet.A * newTripletSet.B * newTripletSet.C
				}
			}
		}
	}
	return answer
}

func Problem10() int {
	max_prime_value := 2000000
	answer := 0
	primesArray := utils.FindAllPrimesSmallerThan(max_prime_value)

	for _, num := range primesArray {
		answer += num
	}
	return answer
}